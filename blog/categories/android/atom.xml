<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Lapisy的博客]]></title>
  <link href="http://blog.lapisy.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.lapisy.com/"/>
  <updated>2020-02-21T21:01:26+08:00</updated>
  <id>http://blog.lapisy.com/</id>
  <author>
    <name><![CDATA[Lapisy]]></name>
    <email><![CDATA[softgeek@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android系统之ANR日志收集过程-Java层]]></title>
    <link href="http://blog.lapisy.com/blog/2019/04/29/androidxi-tong-zhi-anrri-zhi-shou-ji-guo-cheng/"/>
    <updated>2019-04-29T22:24:59+08:00</updated>
    <id>http://blog.lapisy.com/blog/2019/04/29/androidxi-tong-zhi-anrri-zhi-shou-ji-guo-cheng</id>
    <content type="html"><![CDATA[<blockquote><p>文章所有的源码都是基于SDK-28的版本，也就是Android P的版本</p></blockquote>

<h3>一：概述</h3>

<p>我们在解决ANR异常时，一般是利用打印出来的anr log，还有就是发生ANR的栈信息。一般情况下解决ANR步骤为：</p>

<p>&#8195;1. 先利用main log来查看ANR发生的原因，是DispatchTimeout还是BroadcastTimeout，还是ServiceTimeout。同时也可以看发生ANA之前或者之后的各个进程CPU的使用情况。其基本的格式如下：</p>

<pre><code class="java">04-30 08:43:46.009 1638-1668/system_process E/ActivityManager: ANR in com.example.lapisy.apptemplate (com.example.lapisy.apptemplate/.MainActivity)
    PID: 23720
    Reason: Input dispatching timed out (Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago.  Wait queue length: 6.  Wait queue head age: 5533.6ms.)
    Load: 0.89 / 0.44 / 0.34
    CPU usage from 839843ms to 0ms ago (2019-04-18 18:35:53.827 to 2019-04-30 08:43:44.991):
      4.5% 1638/system_server: 3% user + 1.4% kernel / faults: 22176 minor
      2.2% 1387/adbd: 0.2% user + 2% kernel / faults: 49043 minor
      0.8% 1401/android.hardware.graphics.composer@2.1-service: 0% user + 0.7% kernel / faults: 18 minor
      0.4% 1395/android.hardware.audio@2.0-service: 0% user + 0.4% kernel / faults: 3 minor
      0.4% 1491/audioserver: 0.1% user + 0.3% kernel / faults: 7 minor
      0.4% 1413/surfaceflinger: 0.1% user + 0.2% kernel / faults: 49 minor
      0.2% 1780/com.android.systemui: 0.1% user + 0% kernel / faults: 1488 minor
      0.1% 1868/com.android.phone: 0.1% user + 0% kernel / faults: 1056 minor
      0.1% 1335/logd: 0% user + 0% kernel / faults: 47 minor
      0.1% 2223/com.android.launcher3: 0% user + 0% kernel / faults: 2852 minor
      0.1% 7/rcu_preempt: 0% user + 0.1% kernel
        .....
CPU usage from 79ms to 620ms later (2019-04-30 10:29:21.096 to 2019-04-30 10:29:21.637):
      159% 8892/com.huawei.systemmanager: 146% user + 13% kernel / faults: 751 minor 2 major
        92% 9393/pool-3-thread-2: 92% user + 0% kernel
        16% 9436/refresh_permiss: 13% user + 2.7% kernel
        8.1% 8902/HeapTaskDaemon: 8.1% user + 0% kernel
        2.7% 9428/PermissionAppsC: 2.7% user + 0% kernel
       +0% 9453/pool-7-thread-1: 0% user + 0% kernel
       +0% 9457/pool-8-thread-1: 0% user + 0% kernel
      99% 1279/system_server: 45% user + 53% kernel / faults: 1350 minor
        49% 1327/ActivityManager: 12% user + 37% kernel
        14% 1900/Binder:1279_7: 10% user + 4.1% kernel
        12% 11218/Binder:1279_19: 10% user + 2% kernel
       ......
    47% TOTAL: 31% user + 15% kernel + 0.2% softirq
</code></pre>

<!--more-->


<p>&#8195;2. 然后利用traces文件中具体的栈信息，来判断具体的位置和具体的原因。其基本格式和日志如下：</p>

<pre><code class="java">
----- pid 23720 at 2019-04-30 08:43:45 -----
Cmd line: com.example.lapisy.apptemplate
Build fingerprint: 'Android/sdk_phone_x86_64/generic_x86_64:8.0.0/OSR1.180418.004/4931640:userdebug/test-keys'
ABI: 'x86_64'
Build type: optimized
Zygote loaded classes=4675 post zygote classes=217
Intern table: 42644 strong; 137 weak
JNI: CheckJNI is on; globals=524 (plus 22 weak)
Libraries: /system/lib64/libandroid.so /system/lib64/libcompiler_rt.so /system/lib64/libjavacrypto.so /system/lib64/libjnigraphics.so /system/lib64/libmedia_jni.so /system/lib64/libsoundpool.so /system/lib64/libwebviewchromium_loader.so libjavacore.so libopenjdk.so (9)
Heap: 67% free, 725KB/2MB; 17739 objects
Dumping cumulative Gc timings
Start Dumping histograms for 1 iterations for concurrent copying
ResumeRunnableThreads:  Sum: 155.370ms 99% C.I. 155.370ms-155.370ms Avg: 155.370ms Max: 155.370ms
ThreadListFlip: Sum: 90.071ms 99% C.I. 90.071ms-90.071ms Avg: 90.071ms Max: 90.071ms
ProcessMarkStack:   Sum: 30.911ms 99% C.I. 30.911ms-30.911ms Avg: 30.911ms Max: 30.911ms
SweepSystemWeaks:   Sum: 8.240ms 99% C.I. 8.240ms-8.240ms Avg: 8.240ms Max: 8.240ms
VisitConcurrentRoots:   Sum: 5.951ms 99% C.I. 5.951ms-5.951ms Avg: 5.951ms Max: 5.951ms
......
......
concurrent copying total time: 311.388ms mean time: 311.388ms
concurrent copying freed: 5008 objects with total size 2MB
concurrent copying throughput: 16102.9/s / 8MB/s
Cumulative bytes moved 2290824
Cumulative objects moved 51583
Total time spent in GC: 311.388ms
Mean GC size throughput: 8MB/s
Mean GC object throughput: 16082.8 objects/s
Total number of allocations 22747
Total bytes allocated 3MB
Total bytes freed 2MB
Free memory 1504KB
Free memory until GC 1504KB
Free memory until OOME 383MB
Total memory 2MB
Max memory 384MB
Zygote space size 588KB
Total mutator paused time: 606us
Total time waiting for GC to complete: 131.764ms
Total GC count: 1
Total GC time: 311.388ms
Total blocking GC count: 0
Total blocking GC time: 0
Histogram of GC count per 10000 ms: 0:1
Histogram of blocking GC count per 10000 ms: 0:1
Registered native bytes allocated: 3529742
/data/app/com.example.lapisy.apptemplate-2XStSJcJb6Nk1a2drTSdOw==/oat/x86_64/base.odex: quicken
Current JIT code cache size: 3KB
Current JIT data cache size: 4KB
Current JIT capacity: 64KB
Current number of JIT code cache entries: 10
Total number of JIT compilations: 10
Total number of JIT compilations for on stack replacement: 0
Total number of JIT code cache collections: 0
Memory used for stack maps: Avg: 124B Max: 344B Min: 24B
Memory used for compiled code: Avg: 357B Max: 1448B Min: 1B
Memory used for profiling info: Avg: 172B Max: 1208B Min: 32B
Start Dumping histograms for 10 iterations for JIT timings
Compiling:  Sum: 111.851ms 99% C.I. 0.084ms-38.480ms Avg: 11.185ms Max: 38.498ms
TrimMaps:   Sum: 60.285ms 99% C.I. 0.010ms-56.279ms Avg: 6.028ms Max: 58.717ms
Done Dumping histograms
Memory used for compilation: Avg: 91KB Max: 256KB Min: 15KB
ProfileSaver total_bytes_written=0
ProfileSaver total_number_of_writes=0
ProfileSaver total_number_of_code_cache_queries=0
ProfileSaver total_number_of_skipped_writes=0
ProfileSaver total_number_of_failed_writes=0
ProfileSaver total_ms_of_sleep=5000
ProfileSaver total_ms_of_work=0
ProfileSaver max_number_profile_entries_cached=1
ProfileSaver total_number_of_hot_spikes=0
ProfileSaver total_number_of_wake_ups=0

suspend all histogram:  Sum: 189us 99% C.I. 0.320us-43us Avg: 23.625us Max: 43us
DALVIK THREADS (16):
"Signal Catcher" daemon prio=5 tid=3 Runnable
  | group="system" sCount=0 dsCount=0 flags=0 obj=0x14ea5df8 self=0x7e8c4905c400
  | sysTid=23726 nice=0 cgrp=default sched=0/0 handle=0x7e8c3fc064f0
  | state=R schedstat=( 5286484 3613279 4 ) utm=0 stm=0 core=0 HZ=100
  | stack=0x7e8c3fb0c000-0x7e8c3fb0e000 stackSize=1005KB
  | held mutexes= "mutator lock"(shared held)
  native: #00 pc 0000000000435ca5  /system/lib64/libart.so (_ZN3art15DumpNativeStackERNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEiP12BacktraceMapPKcPNS_9ArtMethodEPv+213)
  native: #01 pc 0000000000515b12  /system/lib64/libart.so (_ZNK3art6Thread9DumpStackERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEEbP12BacktraceMapb+322)
  native: #02 pc 000000000052e56e  /system/lib64/libart.so (_ZN3art14DumpCheckpoint3RunEPNS_6ThreadE+926)
  native: #03 pc 0000000000526399  /system/lib64/libart.so (_ZN3art10ThreadList13RunCheckpointEPNS_7ClosureES2_+489)
  native: #04 pc 0000000000525d8b  /system/lib64/libart.so (_ZN3art10ThreadList4DumpERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEEb+747)
  native: #05 pc 0000000000525943  /system/lib64/libart.so (_ZN3art10ThreadList14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+867)
  native: #06 pc 00000000004f7c29  /system/lib64/libart.so (_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+201)
  native: #07 pc 000000000050228e  /system/lib64/libart.so (_ZN3art13SignalCatcher13HandleSigQuitEv+1790)
  native: #08 pc 0000000000500fca  /system/lib64/libart.so (_ZN3art13SignalCatcher3RunEPv+378)
  native: #09 pc 000000000007706b  /system/lib64/libc.so (_ZL15__pthread_startPv+27)
  native: #10 pc 0000000000028aad  /system/lib64/libc.so (__start_thread+61)
  native: #11 pc 0000000000027515  /system/lib64/libc.so (__bionic_clone+53)
  (no managed stack frames)

"main" prio=5 tid=1 Sleeping
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x73ae4670 self=0x7e8c490bea00
  | sysTid=23720 nice=-10 cgrp=default sched=0/0 handle=0x7e8c4df92a08
  | state=S schedstat=( 438163483 342098452 207 ) utm=29 stm=14 core=1 HZ=100
  | stack=0x7fffbf9e8000-0x7fffbf9ea000 stackSize=8MB
  | held mutexes=
  at java.lang.Thread.sleep(Native method)
  - sleeping on &lt;0x03cabe95&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:373)
  - locked &lt;0x03cabe95&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:314)
  at android.os.SystemClock.sleep(SystemClock.java:122)
  at com.example.lapisy.apptemplate.MainActivity$1.onClick(MainActivity.java:77)
  at android.view.View.performClick(View.java:6256)
  at android.view.View$PerformClick.run(View.java:24701)
  at android.os.Handler.handleCallback(Handler.java:789)
  at android.os.Handler.dispatchMessage(Handler.java:98)
  at android.os.Looper.loop(Looper.java:164)
  at android.app.ActivityThread.main(ActivityThread.java:6541)
  at java.lang.reflect.Method.invoke(Native method)
  at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)

"Jit thread pool worker thread 0" daemon prio=5 tid=2 Native
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x14e924b8 self=0x7e8c3f80e000
  | sysTid=23725 nice=9 cgrp=default sched=0/0 handle=0x7e8c3fd074f0
  | state=S schedstat=( 17625138 213848019 39 ) utm=0 stm=1 core=0 HZ=100
  | stack=0x7e8c3fc09000-0x7e8c3fc0b000 stackSize=1021KB
  | held mutexes=
  kernel: futex_wait_queue_me+0xdf/0x130
  kernel: futex_wait+0x113/0x22e
  kernel: do_futex+0xbe/0x825
  kernel: SyS_futex+0xbd/0x124
  kernel: system_call_fastpath+0x12/0x17
  native: #00 pc 00000000000276f6  /system/lib64/libc.so (syscall+22)
  native: #01 pc 000000000014d38e  /system/lib64/libart.so (_ZN3art17ConditionVariable16WaitHoldingLocksEPNS_6ThreadE+110)
  native: #02 pc 0000000000530012  /system/lib64/libart.so (_ZN3art10ThreadPool7GetTaskEPNS_6ThreadE+322)
  native: #03 pc 000000000052f4a1  /system/lib64/libart.so (_ZN3art16ThreadPoolWorker3RunEv+97)
  native: #04 pc 000000000052ef53  /system/lib64/libart.so (_ZN3art16ThreadPoolWorker8CallbackEPv+131)
  native: #05 pc 000000000007706b  /system/lib64/libc.so (_ZL15__pthread_startPv+27)
  native: #06 pc 0000000000028aad  /system/lib64/libc.so (__start_thread+61)
  native: #07 pc 0000000000027515  /system/lib64/libc.so (__bionic_clone+53)
  (no managed stack frames)
  ......
  ......
    ----- end 23720 -----
</code></pre>

<p>那么问题来了，这里就会产生几个问题：</p>

<p>&#8195;1. 这些日志是在哪里收集的呢？</p>

<p>&#8195;2. 收集什么信息？如何收集的？</p>

<p>只有弄明白这两个问题，才能更好的理解和处理ANR问题。</p>

<h3>二：ANR日志的收集过程</h3>

<p>当系统发生anr的时候，都会调用的<code>AppErrors</code>的<code>appNotResponding</code>方法，那我们现在慢慢来看这个函数的整个功能。代码有点长，但是不急，我们慢慢来看（代码基本上没有删减，因为我觉得这些代码得一遍一遍的看，当时觉得不重要的，说不定就是挺重要的，删除了就再也看不到了，这是我自己的一个习惯）。</p>

<pre><code class="java">    final void appNotResponding(ProcessRecord app, ActivityRecord activity,
            ActivityRecord parent, boolean aboveSystem, final String annotation) {
        ArrayList&lt;Integer&gt; firstPids = new ArrayList&lt;Integer&gt;(5);
        SparseArray&lt;Boolean&gt; lastPids = new SparseArray&lt;Boolean&gt;(20);

        if (mService.mController != null) {
            try {
                // 0 == continue, -1 = kill process immediately
                int res = mService.mController.appEarlyNotResponding(
                        app.processName, app.pid, annotation);
                if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {
                    app.kill("anr", true);
                }
            } catch (RemoteException e) {
                mService.mController = null;
                Watchdog.getInstance().setActivityController(null);
            }
        }

        long anrTime = SystemClock.uptimeMillis();
        if (ActivityManagerService.MONITOR_CPU_USAGE) {
            mService.updateCpuStatsNow();
        }

        // Unless configured otherwise, swallow ANRs in background processes &amp; kill the process.
        boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),
                Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;

        boolean isSilentANR;

        synchronized (mService) {
            // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.
            if (mService.mShuttingDown) {
                Slog.i(TAG, "During shutdown skipping ANR: " + app + " " + annotation);
                return;
            } else if (app.notResponding) {
                Slog.i(TAG, "Skipping duplicate ANR: " + app + " " + annotation);
                return;
            } else if (app.crashing) {
                Slog.i(TAG, "Crashing app skipping ANR: " + app + " " + annotation);
                return;
            } else if (app.killedByAm) {
                Slog.i(TAG, "App already killed by AM skipping ANR: " + app + " " + annotation);
                return;
            } else if (app.killed) {
                Slog.i(TAG, "Skipping died app ANR: " + app + " " + annotation);
                return;
            }

            // In case we come through here for the same app before completing
            // this one, mark as anring now so we will bail out.
            app.notResponding = true;

            // Log the ANR to the event log.
            //开始使用EventLog打印ANR的event log
            EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,
                    app.processName, app.info.flags, annotation);
                        //把当前的app添加到最先开始收集栈的列表中
            firstPids.add(app.pid);

            //如果是发生在后台的anr，那么就不收集
            isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);
            if (!isSilentANR) {
                int parentPid = app.pid;
                if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) {
                    parentPid = parent.app.pid;
                }
                if (parentPid != app.pid) firstPids.add(parentPid);

                if (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);

                for (int i = mService.mLruProcesses.size() - 1; i &gt;= 0; i--) {
                    ProcessRecord r = mService.mLruProcesses.get(i);
                    if (r != null &amp;&amp; r.thread != null) {
                        int pid = r.pid;
                        if (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) {
                            if (r.persistent) {
                                firstPids.add(pid);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding persistent proc: " + r);
                            } else if (r.treatLikeActivity) {
                                firstPids.add(pid);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding likely IME: " + r);
                            } else {
                                lastPids.put(pid, Boolean.TRUE);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding ANR proc: " + r);
                            }
                        }
                    }
                }
            }
        }

        // Log the ANR to the main log.
        //这个地方就是向我们的main log中打印ANR日志
        //注释1
        StringBuilder info = new StringBuilder();
        info.setLength(0);
        info.append("ANR in ").append(app.processName);
        if (activity != null &amp;&amp; activity.shortComponentName != null) {
            info.append(" (").append(activity.shortComponentName).append(")");
        }
        info.append("\n");
        info.append("PID: ").append(app.pid).append("\n");
        if (annotation != null) {
            info.append("Reason: ").append(annotation).append("\n");
        }
        if (parent != null &amp;&amp; parent != activity) {
            info.append("Parent: ").append(parent.shortComponentName).append("\n");
        }

        ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);

        // don't dump native PIDs for background ANRs unless it is the process of interest
        String[] nativeProcs = null;
        if (isSilentANR) {
            for (int i = 0; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) {
                if (NATIVE_STACKS_OF_INTEREST[i].equals(app.processName)) {
                    nativeProcs = new String[] { app.processName };
                    break;
                }
            }
        } else {
            nativeProcs = NATIVE_STACKS_OF_INTEREST;
        }

        int[] pids = nativeProcs == null ? null : Process.getPidsForCommands(nativeProcs);
        ArrayList&lt;Integer&gt; nativePids = null;

        if (pids != null) {
            nativePids = new ArrayList&lt;Integer&gt;(pids.length);
            for (int i : pids) {
                nativePids.add(i);
            }
        }

        // For background ANRs, don't pass the ProcessCpuTracker to
        // avoid spending 1/2 second collecting stats to rank lastPids.
        //开始收集发生anr的栈信息到制定的文件中
        //具体分析看[2.1节的分析]
        File tracesFile = ActivityManagerService.dumpStackTraces(
                true, firstPids,
                (isSilentANR) ? null : processCpuTracker,
                (isSilentANR) ? null : lastPids,
                nativePids);

        String cpuInfo = null;
        if (ActivityManagerService.MONITOR_CPU_USAGE) {
            mService.updateCpuStatsNow();
            synchronized (mService.mProcessCpuTracker) {
                //这里会打印cpu中的信息
                //具体看[2.2节分析]
                cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);
            }
            info.append(processCpuTracker.printCurrentLoad());
            info.append(cpuInfo);
        }

        info.append(processCpuTracker.printCurrentState(anrTime));

        Slog.e(TAG, info.toString());
        if (tracesFile == null) {
            // There is no trace file, so dump (only) the alleged culprit's threads to the log
            Process.sendSignal(app.pid, Process.SIGNAL_QUIT);
        }

        StatsLog.write(StatsLog.ANR_OCCURRED, app.uid, app.processName,
                activity == null ? "unknown": activity.shortComponentName, annotation,
                (app.info != null) ? (app.info.isInstantApp()
                        ? StatsLog.ANROCCURRED__IS_INSTANT_APP__TRUE
                        : StatsLog.ANROCCURRED__IS_INSTANT_APP__FALSE)
                        : StatsLog.ANROCCURRED__IS_INSTANT_APP__UNAVAILABLE,
                app != null ? (app.isInterestingToUserLocked()
                        ? StatsLog.ANROCCURRED__FOREGROUND_STATE__FOREGROUND
                        : StatsLog.ANROCCURRED__FOREGROUND_STATE__BACKGROUND)
                        : StatsLog.ANROCCURRED__FOREGROUND_STATE__UNKNOWN);
        mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation,
                cpuInfo, tracesFile, null);

        if (mService.mController != null) {
            try {
                // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately
                int res = mService.mController.appNotResponding(
                        app.processName, app.pid, info.toString());
                if (res != 0) {
                    if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {
                        app.kill("anr", true);
                    } else {
                        synchronized (mService) {
                            mService.mServices.scheduleServiceTimeoutLocked(app);
                        }
                    }
                    return;
                }
            } catch (RemoteException e) {
                mService.mController = null;
                Watchdog.getInstance().setActivityController(null);
            }
        }

        synchronized (mService) {
            mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);

            if (isSilentANR) {
                app.kill("bg anr", true);
                return;
            }

            // Set the app's notResponding state, and look up the errorReportReceiver
            //设置app的notResponding状态，并且查找errorreport的接受者
            makeAppNotRespondingLocked(app,
                    activity != null ? activity.shortComponentName : null,
                    annotation != null ? "ANR " + annotation : "ANR",
                    info.toString());

            // Bring up the infamous App Not Responding dialog
            //发送消息弹出一个anr的弹窗
            Message msg = Message.obtain();
            msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
            msg.obj = new AppNotRespondingDialog.Data(app, activity, aboveSystem);

            mService.mUiHandler.sendMessage(msg);
        }
    }
</code></pre>

<p>&#8195;<strong>注释1</strong>：这个地方就是构造了我们main log中的头部最开始的信息，收集了anr发生的进程，主要原因，也就是下面这一段：</p>

<pre><code class="java">04-30 08:43:46.009 1638-1668/system_process E/ActivityManager: ANR in com.example.lapisy.apptemplate (com.example.lapisy.apptemplate/.MainActivity)
    PID: 23720
    Reason: Input dispatching timed out (Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago.  Wait queue length: 6.  Wait queue head age: 5533.6ms.)
</code></pre>

<h4>2.1 AMS#dumpStackTraces方法</h4>

<p>这个方法主要是手机栈信息，然后把信息写入到制定的文件，全局的文件路径是<code>/data/anr/traces.txt</code>，我们看看他的具体实现：</p>

<pre><code class="java">    /**
     * If a stack trace dump file is configured, dump process stack traces.
     * @param clearTraces causes the dump file to be erased prior to the new
     *    traces being written, if true; when false, the new traces will be
     *    appended to any existing file content.
     * @param firstPids of dalvik VM processes to dump stack traces for first
     * @param lastPids of dalvik VM processes to dump stack traces for last
     * @param nativePids optional list of native pids to dump stack crawls
     */
    public static File dumpStackTraces(boolean clearTraces, ArrayList&lt;Integer&gt; firstPids,
            ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,
            ArrayList&lt;Integer&gt; nativePids) {
        ArrayList&lt;Integer&gt; extraPids = null;

        // Measure CPU usage as soon as we're called in order to get a realistic sampling
        // of the top users at the time of the request.
        if (processCpuTracker != null) {
            processCpuTracker.init();
            try {
                Thread.sleep(200);
            } catch (InterruptedException ignored) {
            }

            processCpuTracker.update();

            // We'll take the stack crawls of just the top apps using CPU.
            final int N = processCpuTracker.countWorkingStats();
            extraPids = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; N &amp;&amp; extraPids.size() &lt; 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) &gt;= 0) {
                    if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);

                    extraPids.add(stats.pid);
                } else if (DEBUG_ANR) {
                    Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: "
                            + stats.pid);
                }
            }
        }

        boolean useTombstonedForJavaTraces = false;
        File tracesFile;
                //判断系统是否配置了存放anr日志的目录，默认情况下是没有配置的,华为手机默认配置为：/data/anr
        //可以使用反射，自己来测试这些值
        final String tracesDirProp = SystemProperties.get("dalvik.vm.stack-trace-dir", "");
        if (tracesDirProp.isEmpty()) {
            // When dalvik.vm.stack-trace-dir is not set, we are using the "old" trace
            // dumping scheme. All traces are written to a global trace file (usually
            // "/data/anr/traces.txt") so the code below must take care to unlink and recreate
            // the file if requested.
            //
            // This mode of operation will be removed in the near future.

                        //得到的是系统默认存放anr日志的路径，默认为/data/anr/trace.txt
            //可以使用反射，自己来测试
            String globalTracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", null);
            if (globalTracesPath.isEmpty()) {
                Slog.w(TAG, "dumpStackTraces: no trace path configured");
                return null;
            }
                        //创建文件
            tracesFile = new File(globalTracesPath);
            try {
                //是否清空原来的文件，默认anr情况下clearTraces为true，清空
                if (clearTraces &amp;&amp; tracesFile.exists()) {
                    tracesFile.delete();
                }

                tracesFile.createNewFile();
                FileUtils.setPermissions(globalTracesPath, 0666, -1, -1); // -rw-rw-rw-
            } catch (IOException e) {
                Slog.w(TAG, "Unable to prepare ANR traces file: " + tracesFile, e);
                return null;
            }
        } else {
            File tracesDir = new File(tracesDirProp);
            // When dalvik.vm.stack-trace-dir is set, we use the "new" trace dumping scheme.
            // Each set of ANR traces is written to a separate file and dumpstate will process
            // all such files and add them to a captured bug report if they're recent enough.
            maybePruneOldTraces(tracesDir);

            // NOTE: We should consider creating the file in native code atomically once we've
            // gotten rid of the old scheme of dumping and lot of the code that deals with paths
            // can be removed.
            tracesFile = createAnrDumpFile(tracesDir);
            if (tracesFile == null) {
                return null;
            }

            useTombstonedForJavaTraces = true;
        }

        dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids,
                useTombstonedForJavaTraces);
        return tracesFile;
    }
</code></pre>

<p>如果是系统配置了<code>dalvik.vm.stack-trace-dir</code>这个属性，则表示使用tombstone的方式来dump日志，那么这种方式下，创建文件的方式是不一样的，我们看<code>createAnrDumpFile</code>方法，如下：</p>

<pre><code class="java">    private static synchronized File createAnrDumpFile(File tracesDir) {
        if (sAnrFileDateFormat == null) {
            sAnrFileDateFormat = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS");
        }

        final String formattedDate = sAnrFileDateFormat.format(new Date());
        //tracesDir，模拟器没有配置，华为手机配置为/data/anr
        final File anrFile = new File(tracesDir, "anr_" + formattedDate);

        try {
            if (anrFile.createNewFile()) {
                FileUtils.setPermissions(anrFile.getAbsolutePath(), 0600, -1, -1); // -rw-------
                return anrFile;
            } else {
                Slog.w(TAG, "Unable to create ANR dump file: createNewFile failed");
            }
        } catch (IOException ioe) {
            Slog.w(TAG, "Exception creating ANR dump file:", ioe);
        }

        return null;
    }
</code></pre>

<p>从上面可以看出，如果配置了<code>dalvik.vm.stack-trace-dir</code>，则存储anr栈信息的文件名称为变为了</p>

<p><strong>tracesDir+&ldquo;anr_&rdquo;+&ldquo;yyyy-MM-dd-HH-mm-ss-SSS&rdquo;</strong>这种命名风格，华为的手机默认就是这种。</p>

<p>进一步调用AMS的dumpStackTraces方法，如下：</p>

<pre><code class="java">    private static void dumpStackTraces(String tracesFile, ArrayList&lt;Integer&gt; firstPids,
            ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids,
            boolean useTombstonedForJavaTraces) {

        // We don't need any sort of inotify based monitoring when we're dumping traces via
        // tombstoned. Data is piped to an "intercept" FD installed in tombstoned so we're in full
        // control of all writes to the file in question.
        final DumpStackFileObserver observer;
        if (useTombstonedForJavaTraces) {
            observer = null;
        } else {
            // Use a FileObserver to detect when traces finish writing.
            // The order of traces is considered important to maintain for legibility.
            observer = new DumpStackFileObserver(tracesFile);
        }

        //我们必须在20s内完成dump stacks的信息
        long remainingTime = 20 * 1000;
        try {
            //利用FileObserver来监听/anr/data/traces.txt目录
            if (observer != null) {
                observer.startWatching();
            }

            // First collect all of the stacks of the most important pids.
            //首先收集最重要pids的栈信息,一般就是直接导致anr的进程，开发中就是我们自己应用的进程
            if (firstPids != null) {
                int num = firstPids.size();
                for (int i = 0; i &lt; num; i++) {
                    if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for pid "
                            + firstPids.get(i));
                    final long timeTaken;
                    //是否使用tombstone来记录java的堆栈信息
                    if (useTombstonedForJavaTraces) {
                        timeTaken = dumpJavaTracesTombstoned(firstPids.get(i), tracesFile, remainingTime);
                    } else {
                        timeTaken = observer.dumpWithTimeout(firstPids.get(i), remainingTime);
                    }

                    remainingTime -= timeTaken;
                    if (remainingTime &lt;= 0) {
                        Slog.e(TAG, "Aborting stack trace dump (current firstPid=" + firstPids.get(i) +
                            "); deadline exceeded.");
                        return;
                    }

                    if (DEBUG_ANR) {
                        Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + timeTaken + "ms");
                    }
                }
            }

            // Next collect the stacks of the native pids
            //如果20s时间还有剩余，那么继续收集那些native进程的堆栈信息
            if (nativePids != null) {
                for (int pid : nativePids) {
                    if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for native pid " + pid);
                    final long nativeDumpTimeoutMs = Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);

                    final long start = SystemClock.elapsedRealtime();
                    Debug.dumpNativeBacktraceToFileTimeout(
                            pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));
                    final long timeTaken = SystemClock.elapsedRealtime() - start;

                    remainingTime -= timeTaken;
                    if (remainingTime &lt;= 0) {
                        Slog.e(TAG, "Aborting stack trace dump (current native pid=" + pid +
                            "); deadline exceeded.");
                        return;
                    }

                    if (DEBUG_ANR) {
                        Slog.d(TAG, "Done with native pid " + pid + " in " + timeTaken + "ms");
                    }
                }
            }


            //最后，如果20s的时间还有剩余，那么收集cpu tracker中所有的其他pid的栈信息
            if (extraPids != null) {
                for (int pid : extraPids) {
                    if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for extra pid " + pid);

                    final long timeTaken;
                    if (useTombstonedForJavaTraces) {
                        timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);
                    } else {
                        timeTaken = observer.dumpWithTimeout(pid, remainingTime);
                    }

                    remainingTime -= timeTaken;
                    if (remainingTime &lt;= 0) {
                        Slog.e(TAG, "Aborting stack trace dump (current extra pid=" + pid +
                                "); deadline exceeded.");
                        return;
                    }

                    if (DEBUG_ANR) {
                        Slog.d(TAG, "Done with extra pid " + pid + " in " + timeTaken + "ms");
                    }
                }
            }
        } finally {
            if (observer != null) {
              //停止监听文件夹
                observer.stopWatching();
            }
        }
    }
</code></pre>

<p>这里有两种不走来获取进程stack</p>

<p>&#8195;1. 使用DumpStackFileObserver的dumpWithTimeout方法来获取堆栈信息</p>

<pre><code class="java">       public long dumpWithTimeout(int pid, long timeout) {
                //发送一个SIGNAL_QUIT信号，开始获取堆栈信息
                //等效于adb shell kill -3 pid
            sendSignal(pid, SIGNAL_QUIT);
            final long start = SystemClock.elapsedRealtime();
                        //timeout传进来的值，最大的为20s，TRACE_DUMP_TIMEOUT_MS默认值为10s
                //等待大概10s钟
            final long waitTime = Math.min(timeout, TRACE_DUMP_TIMEOUT_MS);
            synchronized (this) {
                try {
                    wait(waitTime); // Wait for traces file to be closed.
                } catch (InterruptedException e) {
                    Slog.wtf(TAG, e);
                }
            }

            // This avoids a corner case of passing a negative time to the native
            // trace in case we've already hit the overall timeout.
            final long timeWaited = SystemClock.elapsedRealtime() - start;
            if (timeWaited &gt;= timeout) {
                return timeWaited;
            }
                //public synchronized void onEvent(int event, String path) {
            //  mClosed = true;
            //  notify();
                //}
                        //mclosed值在监视的onEvent方法里置位true，然后条用notify方法,通知不用等待
                //如果等待了timeWaited时间后，anr的traces.txt文件还没有生成，则开始尝试dump
                //native stack的信息
            if (!mClosed) {
                Slog.w(TAG, "Didn't see close of " + mTracesPath + " for pid " + pid +
                       ". Attempting native stack collection.");

                final long nativeDumpTimeoutMs = Math.min(
                        NATIVE_DUMP_TIMEOUT_MS, timeout - timeWaited);

                Debug.dumpNativeBacktraceToFileTimeout(pid, mTracesPath,
                        (int) (nativeDumpTimeoutMs / 1000));
            }

            final long end = SystemClock.elapsedRealtime();
            mClosed = false;

            return (end - start);
        }
    }
</code></pre>

<p>&#8195;2. 利用AMS的dumpJavaTracesTombstoned方法来获取日志</p>

<pre><code class="java">    /**
     * Dump java traces for process {@code pid} to the specified file. If java trace dumping
     * fails, a native backtrace is attempted. Note that the timeout {@code timeoutMs} only applies
     * to the java section of the trace, a further {@code NATIVE_DUMP_TIMEOUT_MS} might be spent
     * attempting to obtain native traces in the case of a failure. Returns the total time spent
     * capturing traces.
     */
    private static long dumpJavaTracesTombstoned(int pid, String fileName, long timeoutMs) {
        final long timeStart = SystemClock.elapsedRealtime();
        if (!Debug.dumpJavaBacktraceToFileTimeout(pid, fileName, (int) (timeoutMs / 1000))) {
            Debug.dumpNativeBacktraceToFileTimeout(pid, fileName,
                    (NATIVE_DUMP_TIMEOUT_MS / 1000));
        }

        return SystemClock.elapsedRealtime() - timeStart;
    }
</code></pre>

<p>这里的逻辑主要还是两部分：</p>

<p>&#8195;1. 使用Debug的dumpJavaBacktraceToFileTimeout方法来dump对应pid的栈信息，如果dump失败，则执行2步</p>

<p>&#8195;2. 在第一步失败后，尝试调用Debug的dumpNativeBacktraceToFileTimeout方法来dump信息，尝试的最大时间为2s</p>

<p>这个方法还是利用Debug类中的dumpNativeBacktraceToFileTimeout这个native方法去获取native stack的信息，并追加到我们的记录anr的日志文件后面，这个方法的具体定义如下：</p>

<pre><code class="java">    /**
     * Append the native stack traces of a given process to a specified file.
     *
     * @param pid pid to dump.
     * @param file path of file to append dump to.
     * @param timeoutSecs time to wait in seconds, or 0 to wait forever.
     * @hide
     */
    public static native boolean dumpNativeBacktraceToFileTimeout(int pid, String file,
                                                                  int timeoutSecs);
</code></pre>

<h4>dump栈信息总结</h4>

<p>在dump栈信息的时候，过程分为：</p>

<p>&#8195;1. 首先判断系统是否配置<code>dalvik.vm.stack-trace-dir</code>属性，如果没有配置，则利用FileObserver来监听全局默认的路径，也就是<code>/data/anr/traces.txt</code>，当发生anr时，会发送<strong>SIGNAL_QUIT</strong>信号，相当于执行了<code>adb shell kill -3 pid</code>，通知系统开始收集Java栈信息，然后写入到全局路径中。如果dump Java栈信息失败，则尝试通过Debug来dump native进程的栈信息，尝试的时间为2s。</p>

<p>&#8195;2. 如果系统配置了<code>dalvik.vm.stack-trace-dir</code>属性，则会标志位useTombstonedForJavaTraces为true，表示使用Debug.dumpJavaBacktraceToFileTimeout方法来dump Java堆栈的信息。</p>

<p>&#8195; 3. 如果上两个步骤完成后，20s钟时间还剩余，则开始dump 一些不是非常重要的native进程的堆栈信息</p>

<p>&#8195; 4. 如果上面三个步骤完后后，20s钟时间还剩余，则开始dump  cpu tracker中所有的其他pid的栈信息(更加的底层)。</p>

<h4>2.2 ProcessCpuTracker cpu信息的收集</h4>

<p>主要是使用<code>printCurrentState</code>方法来收集每个进程的cpu的使用情况。具体看<strong><code>printCurrentState</code></strong>方法实现</p>

<pre><code class="java">   final public String printCurrentState(long now) {
        final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");

        buildWorkingProcs();

        StringWriter sw = new StringWriter();
        PrintWriter pw = new FastPrintWriter(sw, false, 1024);
                //信息的头部
        pw.print("CPU usage from ");
            //判断是ANR前，还是ANR后
        if (now &gt; mLastSampleTime) {
            pw.print(now-mLastSampleTime);
            pw.print("ms to ");
            pw.print(now-mCurrentSampleTime);
            pw.print("ms ago");
        } else {
            pw.print(mLastSampleTime-now);
            pw.print("ms to ");
            pw.print(mCurrentSampleTime-now);
            pw.print("ms later");
        }
        pw.print(" (");
        pw.print(sdf.format(new Date(mLastSampleWallTime)));
        pw.print(" to ");
        pw.print(sdf.format(new Date(mCurrentSampleWallTime)));
        pw.print(")");

        long sampleTime = mCurrentSampleTime - mLastSampleTime;
        long sampleRealTime = mCurrentSampleRealTime - mLastSampleRealTime;
        long percAwake = sampleRealTime &gt; 0 ? ((sampleTime*100) / sampleRealTime) : 0;
        if (percAwake != 100) {
            pw.print(" with ");
            pw.print(percAwake);
            pw.print("% awake");
        }
        pw.println(":");

        final int totalTime = mRelUserTime + mRelSystemTime + mRelIoWaitTime
                + mRelIrqTime + mRelSoftIrqTime + mRelIdleTime;

        if (DEBUG) Slog.i(TAG, "totalTime " + totalTime + " over sample time "
                + (mCurrentSampleTime-mLastSampleTime));

        int N = mWorkingProcs.size();
        for (int i=0; i&lt;N; i++) {
            Stats st = mWorkingProcs.get(i);
            printProcessCPU(pw, st.added ? " +" : (st.removed ? " -": "  "),
                    st.pid, st.name, (int)st.rel_uptime,
                    st.rel_utime, st.rel_stime, 0, 0, 0, st.rel_minfaults, st.rel_majfaults);
            if (!st.removed &amp;&amp; st.workingThreads != null) {
                int M = st.workingThreads.size();
                for (int j=0; j&lt;M; j++) {
                    Stats tst = st.workingThreads.get(j);
                  //打印每个进程的信息
                    printProcessCPU(pw,
                            tst.added ? "   +" : (tst.removed ? "   -": "    "),
                            tst.pid, tst.name, (int)st.rel_uptime,
                            tst.rel_utime, tst.rel_stime, 0, 0, 0, 0, 0);
                }
            }
        }
                //答应total的信息，格式47% TOTAL: 31% user + 15% kernel + 0.2% softirq
        printProcessCPU(pw, "", -1, "TOTAL", totalTime, mRelUserTime, mRelSystemTime,
                mRelIoWaitTime, mRelIrqTime, mRelSoftIrqTime, 0, 0);

        pw.flush();
        return sw.toString();
    }

    private void printProcessCPU(PrintWriter pw, String prefix, int pid, String label,
            int totalTime, int user, int system, int iowait, int irq, int softIrq,
            int minFaults, int majFaults) {
        pw.print(prefix);
        if (totalTime == 0) totalTime = 1;
        printRatio(pw, user+system+iowait+irq+softIrq, totalTime);
        pw.print("% ");
        if (pid &gt;= 0) {
            pw.print(pid);
            pw.print("/");
        }
        pw.print(label);
        pw.print(": ");
        printRatio(pw, user, totalTime);
        pw.print("% user + ");
        printRatio(pw, system, totalTime);
        pw.print("% kernel");
        if (iowait &gt; 0) {
            pw.print(" + ");
            printRatio(pw, iowait, totalTime);
            pw.print("% iowait");
        }
        if (irq &gt; 0) {
            pw.print(" + ");
            printRatio(pw, irq, totalTime);
            pw.print("% irq");
        }
        //https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html
        //softirq 
        if (softIrq &gt; 0) {
            pw.print(" + ");
            printRatio(pw, softIrq, totalTime);
            pw.print("% softirq");
        }
        if (minFaults &gt; 0 || majFaults &gt; 0) {
            pw.print(" / faults:");
            if (minFaults &gt; 0) {
                pw.print(" ");
                pw.print(minFaults);
                pw.print(" minor");
            }
            if (majFaults &gt; 0) {
                pw.print(" ");
                pw.print(majFaults);
                pw.print(" major");
            }
        }
        pw.println();
    }
</code></pre>

<p>这个方法就是打印每个进程，使用cpu的情况，完整的格式如下：</p>

<pre><code class="java">CPU usage from 839843ms to 0ms ago (2019-04-18 18:35:53.827 to 2019-04-30 08:43:44.991):
      4.5% 1638/system_server: 3% user + 1.4% kernel / faults: 22176 minor
      2.2% 1387/adbd: 0.2% user + 2% kernel / faults: 49043 minor
      0.8% 1401/android.hardware.graphics.composer@2.1-service: 0% user + 0.7% kernel / faults: 18 minor
      ......
</code></pre>

<blockquote><p>注意这里有一个<strong>softirq</strong>的耗时的统计，那这个是什么呢？这个softirq是表示软中断的意思，主要是Linux 系统内核里面的程序，具体可以查看<a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html">https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html</a></p></blockquote>

<p><a href="https://www.cnblogs.com/CoderTian/p/5980426.html"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android系统之Watchdog学习解析]]></title>
    <link href="http://blog.lapisy.com/blog/2019/04/23/androidxi-tong-zhi-watchdogxue-xi-jie-xi/"/>
    <updated>2019-04-23T22:56:45+08:00</updated>
    <id>http://blog.lapisy.com/blog/2019/04/23/androidxi-tong-zhi-watchdogxue-xi-jie-xi</id>
    <content type="html"><![CDATA[<h3>一：概述</h3>

<p>Watchdog 顾名思义，看门狗，是一个很重要的机制，其目的是监测系统或者硬件的运行的情况，一旦出现锁死，死机的情况，能及时重启机器（取决于每种实现的设置策略），并收集dump crash日志.</p>

<p>一般情况下有硬件层的Watchdog，也有软件层的Watchdog，例如Linux内核watchdog。但是无论其实现怎么样，但其基本思路包括：</p>

<p>1.假定某一个对象的状态能表征系统运行是否健康（比如interrupt的次数，比如/dev/watchdog的时间戳）;</p>

<p>2.启动一个watchdog程序，定期（通过内部或者外部时钟触发）来观测这个对象，来判定系统是否健康，并采取相应动作。</p>

<h3>二：Android系统中的Watchdog机制</h3>

<p>Android设计了一个软件层面Watchdog，用于保护一些重要的系统服务，当出现故障时，通常会让Android系统重启。由于这种机制的存在，就经常会出现一些system_server进程被Watchdog杀掉而发生手机重启的问题。</p>

<p>所以在Android的Watchdog机制中，我需要弄明白几个问题：</p>

<p>1.Watchdog监视什么？</p>

<p>2.Watchdog如何监视的，也就是判断的条件？</p>

<p>3.Watchdog监视的条件出现问题时，会进行那些操作？</p>

<!--more-->


<h4>2.1 Watchdog初始化</h4>

<p>Android中的Watchdog是单例的线程，他在SystemServer初始化的时候启动，并初始化，如下：</p>

<pre><code class="java">traceBeginAndSlog("InitWatchdog");
final Watchdog watchdog = Watchdog.getInstance();
watchdog.init(context, mActivityManagerService);
traceEnd();
</code></pre>

<p>这段代码的主要原理就是获取Watchdog对象，并调用他的<code>init</code>方法，初始化。我们来看Watchdog的构造函数</p>

<pre><code class="java">    private Watchdog() {
        super("watchdog");
        mMonitorChecker = new HandlerChecker(FgThread.getHandler(),
                "foreground thread", DEFAULT_TIMEOUT);
        mHandlerCheckers.add(mMonitorChecker);
        // Add checker for main thread.  We only do a quick check since there
        // can be UI running on the thread.
        mHandlerCheckers.add(new HandlerChecker(new Handler(Looper.getMainLooper()),
                "main thread", DEFAULT_TIMEOUT));
        // Add checker for shared UI thread.
        mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(),
                "ui thread", DEFAULT_TIMEOUT));
        // And also check IO thread.
        mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(),
                "i/o thread", DEFAULT_TIMEOUT));
        // And the display thread.
        mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(),
                "display thread", DEFAULT_TIMEOUT));

        // Initialize monitor for Binder threads.
        addMonitor(new BinderThreadMonitor());

        mOpenFdMonitor = OpenFdMonitor.create();

        // See the notes on DEFAULT_TIMEOUT.
        assert DB ||
                DEFAULT_TIMEOUT &gt; ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;
    }
</code></pre>

<p>从这个构造函数中可以看到：Watchdog里面创建了很多的HandlerChecker对象，来监视不同的对象，主要分为两大类：</p>

<ul>
<li>Monitor Checker：这个主要是监测那些实现了Monitor接口的对象，主要是监测锁相关的异常，如死锁</li>
<li>Looper Checker：这个主要监测对应线程中的Loop是否阻塞，从构造函数中，我们可以看到主要监测了IO线程，Main线程，AMS等类</li>
</ul>


<h4>2.2 添加Watchdog监视对象</h4>

<p>Watchdog提供了两种接口来添加监视对象，如下：</p>

<pre><code class="java">public void addMonitor(Monitor monitor) {
        synchronized (this) {
            if (isAlive()) {
                throw new RuntimeException("Monitors can't be added once the Watchdog is running");
            }
            mMonitorChecker.addMonitor(monitor);
        }
    }

    public void addThread(Handler thread) {
        addThread(thread, DEFAULT_TIMEOUT);
    }


public void addThread(Handler thread, long timeoutMillis) {
        synchronized (this) {
            if (isAlive()) {
                throw new RuntimeException("Threads can't be added once the Watchdog is running");
            }
            final String name = thread.getLooper().getThread().getName();
            mHandlerCheckers.add(new HandlerChecker(thread, name, timeoutMillis));
        }
    }
</code></pre>

<p>1.一种是通过<code>addMonitor</code>方法来添加Monitor对象，主要是添加到mMonitorChecker中一个Monitor的集合中</p>

<p>2.一种是通过<code>addThread</code>方法来添加Looper是否阻塞，主要是添加到mHandlerCheckers这个列表中</p>

<p>不管通过哪种方式添加，都是构造出了一个HandlerChecker对象，这是一个实现了Runnable接口的类，这个后面再详细讲。</p>

<p>那么系统一共添加了那些监测对象了，通过搜索代码，我们可以知道系统一些重要的Servcice都添加了监视，比如常见的AMS,PMS,PowerManagerService等都添加对应的监听，如下面的ASM的构造函数中：</p>

<pre><code class="java">        Watchdog.getInstance().addMonitor(this);
        Watchdog.getInstance().addThread(mHandler);
</code></pre>

<h4>2.3 Watchdog的启动和监测</h4>

<p>我们知道Watchdog是一个线程，那么他是在哪里启动的呢？他是在ActivityManagerService准备好之后的回调里面执行的，调用了start方法。</p>

<pre><code class="java">        mActivityManagerService.systemReady(() -&gt; {     
            ......
                        traceBeginAndSlog("StartWatchdog");
            Watchdog.getInstance().start();
            traceEnd();
            ......
        }
</code></pre>

<p>启动线程后，会执行Watchdog的run方法，我来看看他的run方法是怎么去监视和处理的</p>

<pre><code class="java">    @Override
    public void run() {
        boolean waitedHalf = false;
      //这里是一个死循环，不断的监测
        while (true) {
            final List&lt;HandlerChecker&gt; blockedCheckers;
            final String subject;
            final boolean allowRestart;
            int debuggerWasConnected = 0;
            synchronized (this) {
              //每次检查的间隔时间，默认是30s
                long timeout = CHECK_INTERVAL;
              //开始遍历所有的HandlerChecker对象，开始检测Looper
              //注释4
                for (int i=0; i&lt;mHandlerCheckers.size(); i++) {
                    HandlerChecker hc = mHandlerCheckers.get(i);
                    hc.scheduleCheckLocked();
                }

                if (debuggerWasConnected &gt; 0) {
                    debuggerWasConnected--;
                }

                // NOTE: We use uptimeMillis() here because we do not want to increment the time we
                // wait while asleep. If the device is asleep then the thing that we are waiting
                // to timeout on is asleep as well and won't have a chance to run, causing a false
                // positive on when to kill things.
              //这个地方就是暂停30s
                long start = SystemClock.uptimeMillis();
                while (timeout &gt; 0) {
                    if (Debug.isDebuggerConnected()) {
                        debuggerWasConnected = 2;
                    }
                    try {
                        wait(timeout);
                    } catch (InterruptedException e) {
                        Log.wtf(TAG, e);
                    }
                    if (Debug.isDebuggerConnected()) {
                        debuggerWasConnected = 2;
                    }
                    timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);
                }

                boolean fdLimitTriggered = false;
                if (mOpenFdMonitor != null) {
                    fdLimitTriggered = mOpenFdMonitor.monitor();
                }

                if (!fdLimitTriggered) {
                  //注释1
                    final int waitState = evaluateCheckerCompletionLocked();
                  //注释2
                    if (waitState == COMPLETED) {
                        // The monitors have returned; reset
                        waitedHalf = false;
                        continue;
                    } else if (waitState == WAITING) {
                        // still waiting but within their configured intervals; back off and recheck
                        continue;
                    } else if (waitState == WAITED_HALF) {
                        if (!waitedHalf) {
                            // We've waited half the deadlock-detection interval.  Pull a stack
                            // trace and wait another half.
                            ArrayList&lt;Integer&gt; pids = new ArrayList&lt;Integer&gt;();
                            pids.add(Process.myPid());
                            ActivityManagerService.dumpStackTraces(true, pids, null, null,
                                getInterestingNativePids());
                            waitedHalf = true;
                        }
                        continue;
                    }

                  //注释3
                    blockedCheckers = getBlockedCheckersLocked();
                    subject = describeCheckersLocked(blockedCheckers);
                } else {
                    blockedCheckers = Collections.emptyList();
                    subject = "Open FD high water mark reached";
                }
                allowRestart = mAllowRestart;
            }

            // If we got here, that means that the system is most likely hung.
            // First collect stack traces from all threads of the system process.
            // Then kill this process so that the system will restart.
          //注释4
            EventLog.writeEvent(EventLogTags.WATCHDOG, subject);

            ArrayList&lt;Integer&gt; pids = new ArrayList&lt;&gt;();
            pids.add(Process.myPid());
            if (mPhonePid &gt; 0) pids.add(mPhonePid);
            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
            final File stack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());

            // Give some extra time to make sure the stack traces get written.
            // The system's been hanging for a minute, another second or two won't hurt much.
            SystemClock.sleep(2000);

            // Trigger the kernel to dump all blocked threads, and backtraces on all CPUs to the kernel log
            doSysRq('w');
            doSysRq('l');

            // Try to add the error to the dropbox, but assuming that the ActivityManager
            // itself may be deadlocked.  (which has happened, causing this statement to
            // deadlock and the watchdog as a whole to be ineffective)
            Thread dropboxThread = new Thread("watchdogWriteToDropbox") {
                    public void run() {
                        mActivity.addErrorToDropBox(
                                "watchdog", null, "system_server", null, null,
                                subject, null, stack, null);
                    }
                };
            dropboxThread.start();
            try {
                dropboxThread.join(2000);  // wait up to 2 seconds for it to return.
            } catch (InterruptedException ignored) {}

            IActivityController controller;
            synchronized (this) {
                controller = mController;
            }
            if (controller != null) {
                Slog.i(TAG, "Reporting stuck state to activity controller");
                try {
                    Binder.setDumpDisabled("Service dumps disabled due to hung system process.");
                    // 1 = keep waiting, -1 = kill system
                    int res = controller.systemNotResponding(subject);
                    if (res &gt;= 0) {
                        Slog.i(TAG, "Activity controller requested to coninue to wait");
                        waitedHalf = false;
                        continue;
                    }
                } catch (RemoteException e) {
                }
            }

            // Only kill the process if the debugger is not attached.
            if (Debug.isDebuggerConnected()) {
                debuggerWasConnected = 2;
            }
            if (debuggerWasConnected &gt;= 2) {
                Slog.w(TAG, "Debugger connected: Watchdog is *not* killing the system process");
            } else if (debuggerWasConnected &gt; 0) {
                Slog.w(TAG, "Debugger was connected: Watchdog is *not* killing the system process");
            } else if (!allowRestart) {
                Slog.w(TAG, "Restart not allowed: Watchdog is *not* killing the system process");
            } else {
                Slog.w(TAG, "*** WATCHDOG KILLING SYSTEM PROCESS: " + subject);
                WatchdogDiagnostics.diagnoseCheckers(blockedCheckers);
                Slog.w(TAG, "*** GOODBYE!");
                Process.killProcess(Process.myPid());
                System.exit(10);
            }

            waitedHalf = false;
        }
    }
</code></pre>

<p>这是run的整个实现，我们一一来看看一些重点的代码：</p>

<p>&#8194; 1. 注释1：在上面等待了固定的时间后，会调用<code>evaluateCheckerCompletionLocked</code>方法去监测各个对象的状态</p>

<p>&#8194;2. 注释2：根据返回的状态，来决定是否继续往下走，还是重复检查，这里涉及三个状态</p>

<p>&#8195;<code>COMPLETED</code>：正常运行，没有阻塞，默认值为0</p>

<p>&#8195;<code>WAITING</code>：如果等待的时间小于最大等待时间的一半时，返回这个值，默认为1</p>

<p>&#8195;<code>WAITED_HALF</code>：如果等待的时间大于最大时间的一半，同时小于最大时间，则返回这个值，默认为2</p>

<p>&#8195;<code>OVERDUE</code>：超过最大的等待时间</p>

<p>具体的可以看<code>getCompletionStateLocked</code>方法对状态的一个判断：</p>

<pre><code class="java">        public int getCompletionStateLocked() {
            if (mCompleted) {
                return COMPLETED;
            } else {
                long latency = SystemClock.uptimeMillis() - mStartTime;
                if (latency &lt; mWaitMax/2) {
                    return WAITING;
                } else if (latency &lt; mWaitMax) {
                    return WAITED_HALF;
                }
            }
            return OVERDUE;
        }
</code></pre>

<p>&#8194;3. 注释3：得到具体的阻塞对象的一些信息</p>

<p>&#8194;4. 注释4：一开始会去调用所有HandlerChecker类的<code>scheduleCheckLocked</code>方法，表示开始去执行检查的代码，而这里的HandlerChecker这个类，是一个实现了Runnable接口的对象，我们先看<code>scheduleCheckLocked</code>方法</p>

<pre><code class="java">        public void scheduleCheckLocked() {
          //监测Looper对应的queue是否空心啊，如果是的话，直接返回，继续检查
            if (mMonitors.size() == 0 &amp;&amp; mHandler.getLooper().getQueue().isPolling()) {
                mCompleted = true;
                return;
            }

            if (!mCompleted) {
                // we already have a check in flight, so no need
                return;
            }

            mCompleted = false;
            mCurrentMonitor = null;
            mStartTime = SystemClock.uptimeMillis();
            mHandler.postAtFrontOfQueue(this);
        }
</code></pre>

<p>这个方法的主要功能是：</p>

<p>&#8194;1. 通过<code>mHandler.getLooper().getQueue().isPolling()</code>判断队列是否在轮询中，如果是，表示队列没有阻塞，mCompleted设置为true，直接返回</p>

<p>&#8194;2. 如果没有，则mCompleted设置为false，然后把当前这个Runnable对象通过<code>postAtFrontOfQueue</code>方法发送到队列头部中，等待执行，如果没有执行，那么mCompleted一直未false，则表示可能阻塞。</p>

<p>一旦这个Runnable对象执行，则会执行他的run方法，我们来看下HandlerChecker的run方法，如下：</p>

<pre><code class="java">@Override
public void run() {
    final int size = mMonitors.size();
    for (int i = 0 ; i &lt; size ; i++) {
        synchronized (Watchdog.this) {
            mCurrentMonitor = mMonitors.get(i);
        }
        mCurrentMonitor.monitor();
    }

    synchronized (Watchdog.this) {
        mCompleted = true;
        mCurrentMonitor = null;
    }
}
</code></pre>

<p>这个方法主要的内容是：</p>

<p>1.调用每个Monitor的monitor方法，来检测锁的状态，其实这个一般实现很简单，如AMS的放这个方法实现：</p>

<pre><code class="java">    /** In this method we try to acquire our lock to make sure that we have not deadlocked */
    public void monitor() {
        synchronized (this) { }
    }
</code></pre>

<p>就是获取锁，如果锁阻塞，那么这个方法会阻塞，Watchdog就会检测到这个异常</p>

<p>2.把mCompleted赋值为true，表示没有问题，顺利执行完了</p>

<h4>2.4 监视对象异常后的操作</h4>

<p>这一块主要是关注Watchdong的run方法，里面有检测</p>

<pre><code class="java">     @Override
    public void run() {
        boolean waitedHalf = false;
        while (true) {
          ......
            //通过EventLog写入watchdog信息
            EventLog.writeEvent(EventLogTags.WATCHDOG, subject);

            ArrayList&lt;Integer&gt; pids = new ArrayList&lt;&gt;();
            pids.add(Process.myPid());
            if (mPhonePid &gt; 0) pids.add(mPhonePid);
            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
          //开始调用ActivityManagerService dump栈信息
            final File stack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());
                        //等待dump操作完成
            SystemClock.sleep(2000);

          //触发内核dump所有的阻塞的线程，backtrace日志
            doSysRq('w');
            doSysRq('l');

            // Try to add the error to the dropbox, but assuming that the ActivityManager
            // itself may be deadlocked.  (which has happened, causing this statement to
            // deadlock and the watchdog as a whole to be ineffective)
          //尝试把错误信息保存到dropbox中
            Thread dropboxThread = new Thread("watchdogWriteToDropbox") {
                    public void run() {
                        mActivity.addErrorToDropBox(
                                "watchdog", null, "system_server", null, null,
                                subject, null, stack, null);
                    }
                };
            dropboxThread.start();
            try {
                dropboxThread.join(2000);  // wait up to 2 seconds for it to return.
            } catch (InterruptedException ignored) {}

            IActivityController controller;
            synchronized (this) {
                controller = mController;
            }
            if (controller != null) {
                Slog.i(TAG, "Reporting stuck state to activity controller");
                try {
                    Binder.setDumpDisabled("Service dumps disabled due to hung system process.");
                    // 1 = keep waiting, -1 = kill system
                    int res = controller.systemNotResponding(subject);
                    if (res &gt;= 0) {
                        Slog.i(TAG, "Activity controller requested to coninue to wait");
                        waitedHalf = false;
                        continue;
                    }
                } catch (RemoteException e) {
                }
            }

            // Only kill the process if the debugger is not attached.
            if (Debug.isDebuggerConnected()) {
                debuggerWasConnected = 2;
            }
            if (debuggerWasConnected &gt;= 2) {
                Slog.w(TAG, "Debugger connected: Watchdog is *not* killing the system process");
            } else if (debuggerWasConnected &gt; 0) {
                Slog.w(TAG, "Debugger was connected: Watchdog is *not* killing the system process");
            } else if (!allowRestart) {
                Slog.w(TAG, "Restart not allowed: Watchdog is *not* killing the system process");
            } else {
              //开始杀死进程，
                Slog.w(TAG, "*** WATCHDOG KILLING SYSTEM PROCESS: " + subject);
                WatchdogDiagnostics.diagnoseCheckers(blockedCheckers);
                Slog.w(TAG, "*** GOODBYE!");
                Process.killProcess(Process.myPid());
                System.exit(10);
            }

            waitedHalf = false;
        }
    }
</code></pre>

<p>发生死锁，异常后，主要的操作为：</p>

<p>&#8194;1. 通过EventLog写入watcndog的event先关信息</p>

<p>&#8194;2. 调用ActivityManagerService dump栈信息</p>

<p>&#8194;3. 触发内核dump所有的阻塞的线程，backtrace日志</p>

<p>&#8194;4. 尝试把错误信息保存到dropbox中</p>

<p>&#8194;5. 并检查activity controller连接的调试器是否可以处理这次watchdog无响应，如果activity controller不要求重启，那么就忽视这次超时，从头继续运行watchdog循环。</p>

<p>&#8194;6. 如果不是debug状态，杀死SystemServer并重启手机，</p>

<h3>三：总结</h3>

<p>整个Watchdog的监测过程如下：</p>

<p>&#8194;1. 在创建SystemServer进程后，创建Watchdog对象，初始化，主要是注册系统reboot的广播监听</p>

<p>&#8194;2. 在AMS准备好后，在器systemReady方法回调中，启动Watchdog线程</p>

<p>&#8194;3. 在一些需要被监听的service中，通过addMonitor和addThread的方法，添加到Watchdog监听中</p>

<p>&#8194;4. Watchdog利用一个死循环，每隔固定的时间（默认为30s）不断的监测对象，主要分为两种：一种是监测Looper队列是否阻塞，如果没有阻塞，则直接返回，继续下次监测。二是监测Monitor对象，并调用monitor方法，判断是否发生死锁。</p>

<p>&#8194;5. 如果发生了死锁或者looper阻塞，则记录下各种日志，并杀死SystemServer进程，重启系统</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android之文件上传原理]]></title>
    <link href="http://blog.lapisy.com/blog/2019/04/21/androidzhi-wen-jian-shang-chuan-yuan-li/"/>
    <updated>2019-04-21T10:43:22+08:00</updated>
    <id>http://blog.lapisy.com/blog/2019/04/21/androidzhi-wen-jian-shang-chuan-yuan-li</id>
    <content type="html"><![CDATA[<h4>基本原理</h4>

<p>我们知道，在浏览器中，我们上传文件时，是这样的（jsp）实现：
<code>java
 &lt;form action="/blog/upload" method="post" enctype="multipart/form-data"&gt;
    &lt;input type="text" name="token"&gt;&lt;br/&gt;
    &lt;input type="file" name="uploadFile"&gt;
    &lt;input type="submit" value="Upload File"&gt;
  &lt;/form&gt;
</code>
我们需要指定表单的方法类型，这里一般是<code>post</code>,<code>enctype</code> 属性规定在发送到服务器之前应该如何对表单数据进行编码，一般有如下几种：
- <strong>application/x-www-form-urlencoded</strong>：在发送前编码所有字符（默认）
- <strong>multipart/form-data</strong>: 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
- <strong>text/plain</strong>:   空格转换为 &ldquo;+&rdquo; 加号，但不对特殊字符编码。</p>

<!--more-->


<p>当点击上传时，可以打开浏览器的网络调试，查看请求体中的数据如下：</p>

<pre><code class="java">------WebKitFormBoundaryT1HoybnYeFOGFlBR
Content-Disposition: form-data; name="token"

xjjdke2m5hkjk3j3k43
------WebKitFormBoundaryT1HoybnYeFOGFlBR
Content-Disposition: form-data; name="file"; filename="ss.jpg"
Content-Type: image/jpeg

....jpg的二进制数据...
------WebKitFormBoundaryT1HoybnYeFOGFlBR--
</code></pre>

<p>从请求中的数据可以看出，请求体中，把所有的数据封装起来，使用<code>------WebKitFormBoundaryT1HoybnYeFOGFlBR</code>来进行隔开，不同类型，一些指定的参数也不一样：
- 如果是简单的键值对，需要指定<code>Content-Disposition</code>也就是内容的描述，同时指定名字和值，也即是<code>name</code>的值以及与其对应的值（这里是token的值）
- 如果是文件的话，不仅要指定内容的描述，name值，还要指定文件的名称<code>filename</code>，内容的类型（如这里传的图片类型），图片的二进制数据</p>

<p>浏览器把这些数据封装到固定的格式后，发送给服务端，而服务端在接受到请求之后，会以这个<code>Boundary</code>的值来分割获取传送过来的值，从而进行处理。</p>

<h4>Android如何来上传文件(不用框架)</h4>

<p>我们知道Android开发时，不像浏览器，会自动的组装这些数据，那么我们在不使用现成的网络请求框架的情况下，如何上传数据呢？
答案很明晰那里 ，只要我们模仿浏览器的行为，人为的把这些数据封装成跟浏览器的一样，放到请求体中，不就可以正常上传了。不多说~~，直接上[<a href="http://blog.csdn.net/lisdye2/article/details/52222645">lisdye2的使用的代码</a>]例子：
```java
/<em>*
 * 文件表单上传
 </em>/
public class FileUpLoadTest {</p>

<pre><code>// 分割符
private static final String BOUNDARY = "----WebKitFormBoundaryT1HoybnYeFOGFlBR";


/**
 * HttpUrlConnection　实现文件上传
 * @param params 普通参数
 * @param fileFormName 文件在表单中的键
 * @param uploadFile 上传的文件
 * @param newFileName 文件在表单中的值（服务端获取到的文件名）
 * @param urlStr url
 * @throws IOException
 */
public static void uploadForm(Map&lt;String, String&gt; params, String fileFormName, File uploadFile, String newFileName,
        String urlStr) throws IOException {

    if (newFileName == null || newFileName.trim().equals("")) {
        newFileName = uploadFile.getName();
    }
    //开始拼接数据
    StringBuilder sb = new StringBuilder();
    /**
     * 普通的表单数据
     */
    if (params != null) {
        for (String key : params.keySet()) {
            sb.append("--" + BOUNDARY + "\r\n");
            sb.append("Content-Disposition: form-data; name=\"" + key + "\"" + "\r\n");
            sb.append("\r\n");
            sb.append(params.get(key) + "\r\n");
        }
    }

    /**
     * 上传文件的头
     */
    sb.append("--" + BOUNDARY + "\r\n");
    sb.append("Content-Disposition: form-data; name=\"" + fileFormName + "\"; filename=\"" + newFileName + "\""
            + "\r\n");
    sb.append("Content-Type: image/jpeg" + "\r\n");// 如果服务器端有文件类型的校验，必须明确指定ContentType
    sb.append("\r\n");

    byte[] headerInfo = sb.toString().getBytes("UTF-8");
    byte[] endInfo = ("\r\n--" + BOUNDARY + "--\r\n").getBytes("UTF-8");


    URL url = new URL(urlStr);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setRequestMethod("POST");
    // 设置传输内容的格式，以及长度
    conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
    conn.setRequestProperty("Content-Length",
            String.valueOf(headerInfo.length + uploadFile.length() + endInfo.length));
    conn.setDoOutput(true);

    OutputStream out = conn.getOutputStream();
    InputStream in = new FileInputStream(uploadFile);
    // 写入头部 （包含了普通的参数，以及文件的标示等）
    out.write(headerInfo);
    // 写入文件
    byte[] buf = new byte[1024];
    int len;
    while ((len = in.read(buf)) != -1) {
        out.write(buf, 0, len);
    }
    // 写入尾部
    out.write(endInfo);
    in.close();
    out.close();
    if (conn.getResponseCode() == 200) {
        System.out.println("文件上传成功");
    }
}

public static void main(String[] args) throws IOException {
    //上传的文件
    File file = new File("ss.png");
    // 普通参数
    HashMap&lt;String , String&gt; params = new HashMap&lt;&gt;();
    params.put("user", "admin");

    uploadForm(params, "file", file, "ss.jpg", "http://localhost:8080/Web/UploadFile");

}
</code></pre>

<p>}
```
上面的代码还是比较简单的，相信大部分人，都能够看懂。其基本的原理就是按照顺序，不断的把数据拼接成服务器能够识别的格式也就是上面讲的格式，然后传递给服务端，让其解析处理即可。</p>

<blockquote><p>总结思考：如果自己想封装一个上传的框架或者工具类，一般会做哪些工作呢？
<strong>从上面例子我们可以看到，上传的数据一般分为：键值对和文件两类，如果封装成一个框架，只需要把外面要传入的键值对即键值对的<code>name</code>和<code>value</code>对外暴露。如果是文件，那只要指定文件的路径，文件的名称(<code>filename</code>)，文件的类型(<code>Content-type</code>)，而我们把拼接流程和请求的流程封装起来，不就完成了封装了吗~~</strong></p></blockquote>

<p>如果想知道框架是怎么上传文件的，可以看下[<a href="http://shiyiliang.cn/2017/06/25/Retrofit%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BC%A0/">Retrofit学习之文件上传</a>]</p>
]]></content>
  </entry>
  
</feed>
