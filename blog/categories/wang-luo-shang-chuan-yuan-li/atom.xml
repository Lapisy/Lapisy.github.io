<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 网络上传原理 | Lapisy的博客]]></title>
  <link href="http://blog.lapisy.com/blog/categories/wang-luo-shang-chuan-yuan-li/atom.xml" rel="self"/>
  <link href="http://blog.lapisy.com/"/>
  <updated>2020-02-21T21:01:26+08:00</updated>
  <id>http://blog.lapisy.com/</id>
  <author>
    <name><![CDATA[Lapisy]]></name>
    <email><![CDATA[softgeek@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android之文件上传原理]]></title>
    <link href="http://blog.lapisy.com/blog/2019/04/21/androidzhi-wen-jian-shang-chuan-yuan-li/"/>
    <updated>2019-04-21T10:43:22+08:00</updated>
    <id>http://blog.lapisy.com/blog/2019/04/21/androidzhi-wen-jian-shang-chuan-yuan-li</id>
    <content type="html"><![CDATA[<h4>基本原理</h4>

<p>我们知道，在浏览器中，我们上传文件时，是这样的（jsp）实现：
<code>java
 &lt;form action="/blog/upload" method="post" enctype="multipart/form-data"&gt;
    &lt;input type="text" name="token"&gt;&lt;br/&gt;
    &lt;input type="file" name="uploadFile"&gt;
    &lt;input type="submit" value="Upload File"&gt;
  &lt;/form&gt;
</code>
我们需要指定表单的方法类型，这里一般是<code>post</code>,<code>enctype</code> 属性规定在发送到服务器之前应该如何对表单数据进行编码，一般有如下几种：
- <strong>application/x-www-form-urlencoded</strong>：在发送前编码所有字符（默认）
- <strong>multipart/form-data</strong>: 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
- <strong>text/plain</strong>:   空格转换为 &ldquo;+&rdquo; 加号，但不对特殊字符编码。</p>

<!--more-->


<p>当点击上传时，可以打开浏览器的网络调试，查看请求体中的数据如下：</p>

<pre><code class="java">------WebKitFormBoundaryT1HoybnYeFOGFlBR
Content-Disposition: form-data; name="token"

xjjdke2m5hkjk3j3k43
------WebKitFormBoundaryT1HoybnYeFOGFlBR
Content-Disposition: form-data; name="file"; filename="ss.jpg"
Content-Type: image/jpeg

....jpg的二进制数据...
------WebKitFormBoundaryT1HoybnYeFOGFlBR--
</code></pre>

<p>从请求中的数据可以看出，请求体中，把所有的数据封装起来，使用<code>------WebKitFormBoundaryT1HoybnYeFOGFlBR</code>来进行隔开，不同类型，一些指定的参数也不一样：
- 如果是简单的键值对，需要指定<code>Content-Disposition</code>也就是内容的描述，同时指定名字和值，也即是<code>name</code>的值以及与其对应的值（这里是token的值）
- 如果是文件的话，不仅要指定内容的描述，name值，还要指定文件的名称<code>filename</code>，内容的类型（如这里传的图片类型），图片的二进制数据</p>

<p>浏览器把这些数据封装到固定的格式后，发送给服务端，而服务端在接受到请求之后，会以这个<code>Boundary</code>的值来分割获取传送过来的值，从而进行处理。</p>

<h4>Android如何来上传文件(不用框架)</h4>

<p>我们知道Android开发时，不像浏览器，会自动的组装这些数据，那么我们在不使用现成的网络请求框架的情况下，如何上传数据呢？
答案很明晰那里 ，只要我们模仿浏览器的行为，人为的把这些数据封装成跟浏览器的一样，放到请求体中，不就可以正常上传了。不多说~~，直接上[<a href="http://blog.csdn.net/lisdye2/article/details/52222645">lisdye2的使用的代码</a>]例子：
```java
/<em>*
 * 文件表单上传
 </em>/
public class FileUpLoadTest {</p>

<pre><code>// 分割符
private static final String BOUNDARY = "----WebKitFormBoundaryT1HoybnYeFOGFlBR";


/**
 * HttpUrlConnection　实现文件上传
 * @param params 普通参数
 * @param fileFormName 文件在表单中的键
 * @param uploadFile 上传的文件
 * @param newFileName 文件在表单中的值（服务端获取到的文件名）
 * @param urlStr url
 * @throws IOException
 */
public static void uploadForm(Map&lt;String, String&gt; params, String fileFormName, File uploadFile, String newFileName,
        String urlStr) throws IOException {

    if (newFileName == null || newFileName.trim().equals("")) {
        newFileName = uploadFile.getName();
    }
    //开始拼接数据
    StringBuilder sb = new StringBuilder();
    /**
     * 普通的表单数据
     */
    if (params != null) {
        for (String key : params.keySet()) {
            sb.append("--" + BOUNDARY + "\r\n");
            sb.append("Content-Disposition: form-data; name=\"" + key + "\"" + "\r\n");
            sb.append("\r\n");
            sb.append(params.get(key) + "\r\n");
        }
    }

    /**
     * 上传文件的头
     */
    sb.append("--" + BOUNDARY + "\r\n");
    sb.append("Content-Disposition: form-data; name=\"" + fileFormName + "\"; filename=\"" + newFileName + "\""
            + "\r\n");
    sb.append("Content-Type: image/jpeg" + "\r\n");// 如果服务器端有文件类型的校验，必须明确指定ContentType
    sb.append("\r\n");

    byte[] headerInfo = sb.toString().getBytes("UTF-8");
    byte[] endInfo = ("\r\n--" + BOUNDARY + "--\r\n").getBytes("UTF-8");


    URL url = new URL(urlStr);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setRequestMethod("POST");
    // 设置传输内容的格式，以及长度
    conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
    conn.setRequestProperty("Content-Length",
            String.valueOf(headerInfo.length + uploadFile.length() + endInfo.length));
    conn.setDoOutput(true);

    OutputStream out = conn.getOutputStream();
    InputStream in = new FileInputStream(uploadFile);
    // 写入头部 （包含了普通的参数，以及文件的标示等）
    out.write(headerInfo);
    // 写入文件
    byte[] buf = new byte[1024];
    int len;
    while ((len = in.read(buf)) != -1) {
        out.write(buf, 0, len);
    }
    // 写入尾部
    out.write(endInfo);
    in.close();
    out.close();
    if (conn.getResponseCode() == 200) {
        System.out.println("文件上传成功");
    }
}

public static void main(String[] args) throws IOException {
    //上传的文件
    File file = new File("ss.png");
    // 普通参数
    HashMap&lt;String , String&gt; params = new HashMap&lt;&gt;();
    params.put("user", "admin");

    uploadForm(params, "file", file, "ss.jpg", "http://localhost:8080/Web/UploadFile");

}
</code></pre>

<p>}
```
上面的代码还是比较简单的，相信大部分人，都能够看懂。其基本的原理就是按照顺序，不断的把数据拼接成服务器能够识别的格式也就是上面讲的格式，然后传递给服务端，让其解析处理即可。</p>

<blockquote><p>总结思考：如果自己想封装一个上传的框架或者工具类，一般会做哪些工作呢？
<strong>从上面例子我们可以看到，上传的数据一般分为：键值对和文件两类，如果封装成一个框架，只需要把外面要传入的键值对即键值对的<code>name</code>和<code>value</code>对外暴露。如果是文件，那只要指定文件的路径，文件的名称(<code>filename</code>)，文件的类型(<code>Content-type</code>)，而我们把拼接流程和请求的流程封装起来，不就完成了封装了吗~~</strong></p></blockquote>

<p>如果想知道框架是怎么上传文件的，可以看下[<a href="http://shiyiliang.cn/2017/06/25/Retrofit%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BC%A0/">Retrofit学习之文件上传</a>]</p>
]]></content>
  </entry>
  
</feed>
